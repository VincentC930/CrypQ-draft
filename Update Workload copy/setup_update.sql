CREATE TABLE CURR_ADDRESSES (
	address VARCHAR(42),
	eth_balance NUMERIC,
    adjusted BOOLEAN,
	PRIMARY KEY (address)
);

CREATE TABLE CURR_BLOCKS (
    hash VARCHAR(66) PRIMARY KEY,
    number NUMERIC,
    timestamp TIMESTAMP WITH TIME ZONE,
    extra_data VARCHAR(8192), -- 32 byte field on the blockchain
    base_fee_per_gas NUMERIC,
    size NUMERIC,
    miner VARCHAR(42) REFERENCES CURR_ADDRESSES(address)
);

CREATE TABLE CURR_WITHDRAWALS (
    hash VARCHAR(66) REFERENCES CURR_BLOCKS(hash) ,
    withdrawal_index NUMERIC,
    validator NUMERIC,
    address VARCHAR(42) REFERENCES CURR_ADDRESSES(address),
    amount NUMERIC,
    PRIMARY KEY (hash, withdrawal_index)
);

CREATE TABLE CURR_TRANSACTIONS (
    hash VARCHAR(66) PRIMARY KEY,
    transaction_index NUMERIC,
    value NUMERIC,
    from_address VARCHAR(42) REFERENCES CURR_ADDRESSES(address),
    to_address VARCHAR(42) REFERENCES CURR_ADDRESSES(address),
    gas NUMERIC,
    max_priority_fee_per_gas NUMERIC,
    input VARCHAR(8192),
    block_hash VARCHAR(66) REFERENCES CURR_BLOCKS(hash),
    transaction_type NUMERIC,
    nonce NUMERIC
);

CREATE TABLE CURR_TOKENS (
    address VARCHAR(42) PRIMARY KEY,
    symbol VARCHAR(20),
    name VARCHAR(100),
    decimals NUMERIC,
    total_supply NUMERIC,
    block_hash VARCHAR(66) REFERENCES CURR_BLOCKS(hash),
    MISSING_FROM_BQ BOOLEAN
);

CREATE TABLE CURR_TOKEN_TRANSACTIONS (
    transaction_hash VARCHAR(66) REFERENCES CURR_TRANSACTIONS(hash),
    log_index NUMERIC,
    token_address VARCHAR(42) REFERENCES CURR_TOKENS(address),
    value NUMERIC,
    PRIMARY KEY (transaction_hash, log_index)
);

CREATE TABLE CURR_CONTRACTS (
    address VARCHAR(42) REFERENCES CURR_ADDRESSES(address),
    version NUMERIC,
    function_sighashes VARCHAR(1024), -- 4 bytes on blockchain
    bytecode VARCHAR(8192),
    is_erc20 BOOLEAN,
    is_erc721 BOOLEAN,
    block_hash VARCHAR(66) REFERENCES CURR_BLOCKS(hash),
    PRIMARY KEY (address, version)
);

-- ETH balances at the beginning of our window
CREATE TEMPORARY TABLE Temp_Relevant_From AS
SELECT DISTINCT from_address AS address
FROM TRANSACTIONS
JOIN BLOCKS ON TRANSACTIONS.block_hash = BLOCKS.hash
WHERE BLOCKS.number BETWEEN 19005000 AND 19005999;

CREATE TEMPORARY TABLE Temp_Relevant_To AS
SELECT DISTINCT to_address AS address
FROM TRANSACTIONS
JOIN BLOCKS ON TRANSACTIONS.block_hash = BLOCKS.hash
WHERE BLOCKS.number BETWEEN 19005000 AND 19005999;

CREATE TEMPORARY TABLE Temp_Relevant_Miner AS
SELECT DISTINCT miner AS address
FROM BLOCKS
WHERE number BETWEEN 19005000 AND 19005999;

CREATE TEMPORARY TABLE Temp_Relevant_Withdrawals AS
SELECT DISTINCT withdrawals.address
FROM WITHDRAWALS
JOIN BLOCKS ON WITHDRAWALS.hash = BLOCKS.hash
WHERE BLOCKS.number BETWEEN 19005000 AND 19005999;

CREATE TEMPORARY TABLE Temp_Contract_Addresses AS
SELECT contracts.address
FROM BLOCKS
JOIN TRANSACTIONS ON BLOCKS.hash = TRANSACTIONS.block_hash
JOIN CONTRACTS ON TRANSACTIONS.to_address = CONTRACTS.address
WHERE BLOCKS.number BETWEEN 19005000 AND 19005999
UNION
SELECT contracts.address
FROM CONTRACTS, BLOCKS
WHERE CONTRACTS.BLOCK_HASH = BLOCKS.HASH
AND BLOCKS.number BETWEEN 19005000 AND 19005999;

INSERT INTO CURR_ADDRESSES (address, eth_balance)
WITH Relevant_Address AS (
    SELECT address FROM Temp_Relevant_From
	UNION
	SELECT address FROM Temp_Relevant_To
	UNION
	SELECT address FROM Temp_Relevant_Miner
	UNION
	SELECT address FROM Temp_Relevant_Withdrawals
    UNION 
    SELECT address FROM Temp_Contract_Addresses
),
Relevant_Address_And_Balance AS (
	SELECT ADDRESSES.address, ADDRESSES.eth_balance
	FROM ADDRESSES, RELEVANT_ADDRESS
	WHERE ADDRESSES.ADDRESS = RELEVANT_ADDRESS.ADDRESS
),
Sent AS (
    SELECT from_address AS address, SUM(value) AS total_sent
    FROM TRANSACTIONS
    WHERE BLOCK_HASH IN (
        SELECT HASH
        FROM BLOCKS
        WHERE NUMBER > 19005999
    )
    GROUP BY from_address
),
Received AS (
    SELECT to_address AS address, SUM(value) AS total_received
    FROM TRANSACTIONS
    WHERE BLOCK_HASH IN (
        SELECT HASH
        FROM BLOCKS
        WHERE NUMBER > 19005999
    )
    GROUP BY to_address
)
SELECT A.address, COALESCE(A.eth_balance, 0) - COALESCE(S.total_sent, 0) + COALESCE(R.total_received, 0)
FROM Relevant_Address_And_Balance A
LEFT JOIN Sent S ON A.address = S.address
LEFT JOIN Received R ON A.address = R.address;

INSERT INTO CURR_BLOCKS
SELECT *
FROM BLOCKS
WHERE NUMBER BETWEEN 19005000 AND 19005999;

INSERT INTO CURR_CONTRACTS
SELECT *
FROM CONTRACTS
WHERE ADDRESS IN (
    SELECT TO_ADDRESS
    FROM CURR_TRANSACTIONS
) OR BLOCK_HASH IN (
    SELECT HASH
    FROM CURR_BLOCKS
);

INSERT INTO CURR_TRANSACTIONS
SELECT *
FROM TRANSACTIONS
WHERE BLOCK_HASH IN (SELECT HASH FROM CURR_BLOCKS);


INSERT INTO CURR_TOKENS
WITH T_T AS (
    SELECT TOKEN_ADDRESS
    FROM TOKEN_TRANSACTIONS
    WHERE TRANSACTION_HASH IN (SELECT HASH FROM CURR_TRANSACTIONS)
)
SELECT *
FROM TOKENS
WHERE ADDRESS IN (
    SELECT TOKEN_ADDRESS
    FROM T_T
) OR BLOCK_HASH IN (
    SELECT HASH
    FROM CURR_BLOCKS
);

INSERT INTO CURR_TOKEN_TRANSACTIONS
SELECT *
FROM TOKEN_TRANSACTIONS
WHERE TRANSACTION_HASH IN (SELECT HASH FROM CURR_TRANSACTIONS);

INSERT INTO CURR_WITHDRAWALS
SELECT *
FROM WITHDRAWALS
WHERE HASH IN (SELECT HASH FROM CURR_BLOCKS);

DROP TABLE IF EXISTS Temp_Relevant_From CASCADE;
DROP TABLE IF EXISTS Temp_Relevant_To CASCADE;
DROP TABLE IF EXISTS Temp_Relevant_Miner CASCADE;
DROP TABLE IF EXISTS Temp_Relevant_Withdrawals CASCADE;
DROP TABLE IF EXISTS Temp_Contract_Addresses CASCADE;